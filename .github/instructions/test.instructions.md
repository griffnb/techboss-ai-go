---
applyTo: '**/*_test.go'
---

USE ONLY `#code_tools` for formatting / linting / testing
**If tables do not exist or you need to rebuild due to migrations, use `#code_tools/rebuild_unit_test_db`**



- Write unit tests in a single function with each conditional test being written in its own t.Run("Condition im looking for")
-  There is a testing service to help generate objects, testing_service.New().WithAccount().WithOrganization() etc, it will help build test objects properly
- use the testing library to assert.Eq(t,got,want,"description"), it uses generics so got and want can be anything
- Suggest comprehensive testing strategies rather than just example tests, including considerations for mocking, test organization, and coverage.



## üß™ CRITICAL: TEST-DRIVEN DEVELOPMENT (TDD) IS MANDATORY

**‚ö†Ô∏è ABSOLUTE RULE - NO EXCEPTIONS**: This project follows **strict TDD (Test-Driven Development)**.
**at the top of the test function write a comment //GENERATED BY AI** 

### TDD Workflow - ALWAYS FOLLOW THIS ORDER:

1. **üî¥ RED**: Write the test FIRST (it will fail)
2. **üü¢ GREEN**: Write minimal code to make it pass
3. **üîµ REFACTOR**: Clean up the code while keeping tests green
4. **üìù COMMIT**: Commit with passing tests

### Before Writing ANY Code:

```
‚ùå WRONG:
1. Write implementation
2. Write tests later
3. Maybe forget tests

‚úÖ CORRECT:
1. Write test first (see it fail - RED)
2. Write minimal implementation (make it pass - GREEN)
3. Refactor if needed (keep it passing - REFACTOR)
4. Commit with tests passing
```

### TDD Rules for This Project:

1. **NEVER** write production code without a failing test first
2. **NEVER** write more of a test than is sufficient to fail
3. **NEVER** write more production code than is sufficient to pass the test
4. **ALWAYS** see the test fail before making it pass
5. **ALWAYS** commit only when all tests are passing
6. **Test coverage must be ‚â•90%** for new code

### What to Test:

- **Unit tests**: All business logic, domain models, services
- **Integration tests**: Database interactions, external APIs
- **HTTP handler tests**: All endpoints with various scenarios
- **Edge cases**: Errors, nil values, boundary conditions
- **Happy paths**: Normal successful flows

### Test Quality Standards:

- Use **table-driven tests** for multiple scenarios
- Mock external dependencies if a function doesnt accept the data directly. To mock database queries, implement the interface that is defined in the /{model}/queries.go and use model.SetMocker to add it to the context. **IMPORTANT** seperate out mock tests from real tests, always have both to make sure the underlying data is real and accurate
- Use `assert` (lib/testtools/assert/assert.go) for assertions
- Use `testing_service.Builder` to build objects, be sure to extend this as objects change
- Tests must be **isolated** (no shared state)
- Tests must be **deterministic** (no flaky tests)


### Example TDD Session:

```go
// Step 1: Write test FIRST (RED)
func TestExampleHere(t *testing.T) {

    t.Run("Case 1", func(t *testing.T) {
        // Arrange
        client := NewOpenAIClient("test-key", "gpt-4")
        req := llm.CreateVectorStoreRequest{Name: "test"}

        // Act
        result, err := client.CreateVectorStore(context.Background(), req)

        // Assert
        
        assert.Equal(t, "test", result.Name)
    })

    t.Run("Case 2", func(t *testing.T) {
        // Arrange
        client := NewOpenAIClient("test-key", "gpt-4")
        req := llm.CreateVectorStoreRequest{Name: "test"}

        // Act
        result, err := client.CreateVectorStore(context.Background(), req)

        // Assert
        
        assert.Equal(t, "test", result.Name)
    })

     t.Run("Case 3", func(t *testing.T) {
        // Arrange
        client := NewOpenAIClient("test-key", "gpt-4")
        req := llm.CreateVectorStoreRequest{Name: "test"}

        // Act
        result, err := client.CreateVectorStore(context.Background(), req)

        // Assert
        
        assert.Equal(t, "test", result.Name)
    })
}

// Step 2: Run test - it FAILS (RED) ‚úÖ
// Step 3: Write implementation to make it pass (GREEN) ‚úÖ
// Step 4: Refactor if needed (REFACTOR) ‚úÖ
// Step 5: Commit with passing tests ‚úÖ
```

### Running Tests:

All tests must be run through `#code_tools` to ensure proper environment setup:
** DO NOT RUN YOUR OWN COMMANDS, ONLY USE `#code_tools`